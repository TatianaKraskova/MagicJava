package main.java.org.hogwarts;

public class MagicCourseLectures {

    /*
    * Переменные и типы данных
📄 45 мин

— Сегодня мы с вами будем превращать животных в сосуды для жидкостей. Раз, два, три — Fera Verto!

Огромная птица, сидевшая перед Макгонагалл, превращается в хрустальный бокал. Вы в смятении — а как вернуть птицу?!


На самом деле, мы собираемся посмотреть, как обычные числа, строки и логические выражения помещаются в своего рода оболочки, которые позволяют разработчикам работать с ними и понимать, какой именно формат данных ожидается в том или ином месте. Что же тут необычного? А то, что разработчиками была придумана целая система разных типов данных, которая позволила унифицировать обработку различных представлений информации! То, что обычный человек-магл называет числом, волшебники могут называть int, double, float, short и даже, представьте себе, byte! Давайте разберемся, что это за превращения такие.

Любая программа работает с данными, которые нужно хранить. Именно для этой цели существуют переменные.

Переменные — это контейнеры, в которых можно хранить различные виды информации. Чтобы создать переменную, нужно придумать для нее имя и указать ее тип. Например, так:

String name;
Так мы создали тот самый контейнер с типом String (строка) и именем name. Пока что в этой переменной ничего не лежит, но это очень просто исправить:

String name = "Ronald Weasley";
Так мы поместили строку в переменную строкового типа. Также, мы можем создать много переменных разного типа и присвоить им значения. Обратите внимание, что каждая строчка обязательно заканчивается символом ;:

// **[тип] [название]** *= [значение]*
float result;                    // объявление переменной
String name = "Ronald Weasley";  // объявление и инициализация переменной
int b, c = 4, d;                 // объявление нескольких переменных
byte = 1;

int def_123 = 5;                 // правильное название переменной
int 123abc = 123;                // неправильное название переменной
Сначала пишется тип переменной, затем через пробел название переменной. При необходимости через знак = можно сразу присвоить переменной какое-то значение. Этот процесс присвоения переменной какого-то значения называется инициализацией.

💡 Правило: название переменной может состоять из букв английского алфавита, чисел и знака нижнего подчёркивания, при этом название переменной не может начинаться с цифры. См. два последних примера в блоке кода выше.

Обратим внимание на строку int b, c = 4, d;. Java устроена так, что мы можем объявлять переменные одного типа на одной и той же строке через запятую. Это не очень частая практика, но все же программисты ей пользуются. При этом также важно заметить, что некоторые переменные можно инициализировать сразу, а некоторые нет. И это будет работать!

Теперь, когда мы познакомились с общей концепцией, давайте перейдем к рассмотрению популярных типов данных. Начнём с численных типов:

целое число int (например: 0, 500, 189645)

целое число побольше long (например: 1L, 25897564L)

число с плавающей точкой float (например: 0.1546f, 3.14f)

число с плавающей точкой побольше double (например, 9.54654, 0.11)

float pi = 3.14f;
double e = 2.718281828;
int a = 3228;
long b = 12345678900987654321L;
Обратите внимание, для float нужно в конце написать f или F, что бы показать, что это именно float, а не double. Также для порядка можно писать L для long.

Эти типы данных отличаются тем, что хранятся по разному в оперативной памяти компьютера. int и float занимают 32 бита, а long и double занимают 64 бита, т.е. эти типы могут хранить числа побольше, но при этом занимают больше памяти. Поэтому полезно заранее подумать: будет ли ваша программа использовать такое большое число, чтобы выбрать long вместо int?


Данные программы хранятся в оперативной памяти. Эта память выглядит как большая таблица, где каждая строка нумеруется (адресуется) и хранит обычно 32 или 64 бита информации. Это 32 или 64 ячейки памяти, где каждая ячейка содержит либо 0, либо 1. Если внутри ячейки единица, значит, ячейка занята, а если ноль — свободна.

Теперь перейдем к математике.

Числа можно складывать, вычитать, умножать и делить с помощью привычных нам знаков:

int a = 12, b = 4;
int resultPlus = a + b;
int resultMinus = a - b;
int resultMul = a * b;
int resultDiv = a / b
int result = resultPlus + resultMinus + resultMul + resultDiv - 1000;
Можно расставлять скобки, чтобы уточнить приоритет операций:

// по приотету сначала вычисляется умножение и деление,
// а затем сумма и разность - все по математическим правилам
int a = 1 + 2 * 5;           // будет равно 11
int b = (1 + 2) * 5;         // будет равно 15
int c = 5 * 5 - (4 / 2 - 4); // будет равно 25 - (2 - 4) = 25 + 2 = 27
Только для целых чисел int и long, поддерживается остаток от деления:

int a = 5 % 3;   // Получится остаток **2**, потому что 5 не делится на цело на 3
long b = 50 % 10 // Получится остаток **0**, потому что 50 на цело делится на 10
А ещё есть короткий способ записи операций:

int counter = 5;
counter++;    // Добавляет единицу
++counter;    // Можно наоборот, тоже добавляет единицу
counter += 3; // Добавляет 3 к переменной
counter /= 2; // Делит на 2
counter *= 2; // Умножает на 2
Отдельно стоит посмотреть на специальный логический тип boolean, значение которого может быть только true или false

boolean isMuggle = false;
boolean introCourseIsGreat = true;
Так же как с числами, с логическим типом boolean можно совершать различные операции: ==, !=, &&, ||

== — знак равенства, true если выражения по обе стороны равны

!= — знак неравенства, true если выражения по обе стороны не равны

>, ≥, <, ≤ — операторы сравнения (работают только для чисел)

&& — означает И, т.е. выражения по обе стороны должны быть true

|| — означает ИЛИ, т.е. хотя бы одно выражение слева или справа должно быть true

Рассмотрим каждую операцию на примерах:

int number = new Random().nextInt();       // создаем рандомное число
boolean isFirstEven = number % 2 == 0;     // Если число чётное - равно true, иначе false
boolean isSecondOdd = number % 2 != 0;     // Если число нечётное равно true, иначе false

int number2 = new Random().nextInt();      // создаем еще одно рандомное число
boolean isFirstBigger = number > number2 ; // Если первое больше, равно true, иначе false
boolean isFirstLowerOrEqual = number <= number2 ;

// При вычислении можно использовать другие boolean переменные
// Так же можно расставлять скобки для приоритезации
boolean result = (isFirstEven && isSecondOdd) || isFirstBigger;
На примере выше result будет равен true если первое число чётное и второе число нечётное одновременно, или же если первое число просто больше второго. Например: При r1 = 2 и r2 = 5 будет равно true При r1 = 7 и r2 = 4 тоже будет равно true При r1 = 8 и r2 = 10 будет равно false

А ещё есть простой символьный тип char, который хранит в себе один символ из кодировки UTF-8. На самом деле char тоже численный тип, который внутри себя хранит число из таблицы ASCII. Это код символа.

char a = 'a'; // Код символа – 97 из таблицы ASCII
char b = 'b'; // Код символа – 98 из таблицы ASCII
А вот вам магия на последок!

Результат математической операции над 2-мя char равен числу int:

char a = 'a';
char b = 'b';

int resultSum = a + b; // result = 97 + 98 = 195
int resultDiv = a - b; // result = 97 - 98 = -1
Лекции — это лишь полдела. Давайте потренируемся на реальных задачах в нашем проекте Magic!
    *
    *
    * Первое задание
В методе main класса Main создайте 5 переменных типа String: dumbledore, mcgonagall, snape, lupin, hugrid. Присвойте каждой переменной значение, соответствующее ее названию. Должны получиться поля, содержащие имена знаменитых волшебников.

Затем создайте еще одну строку с названием teachers, содержащую текст: “School teachers:“. Обратите внимание, в тексте содержится двоеточие.

Выведите на экран сначала строку teachers, затем все 5 строк с именами преподавателей. Должен получиться список учителей.

Второе задание
Теперь представим, что Макгонагалл выставляет оценки за работу с помощью магического пера. Перо умеет проверять само — оно отлично знает материал.

Давайте поставим оценки за две работы. Для этого будем использовать класс Random.

С помощью new Random().nextInt(1, 10) сгенерируйте 2 разных числа grade1, grade2. Обратите внимание, что класс Random вообще призван, чтобы всегда генерировать случайное число. Тут мы указали конкретный диапазон, потому что работу можно оценить от 1 до 10. Но можно диапазон и не указывать. Каждый раз, когда мы будем вызывать этот метод, будет генерироваться новое число.

Теперь давайте проверим, что оба числа больше 5 — это приемлемая для сдачи работы оценка. Используем операции сравнения и &&, чтобы выполнить две проверки на одной строчке. Результат выполнения записываем в переменную типа boolean c названием result. Затем выводим result на экран. Так, если оба числа были больше 5, в результате мы должны получить true. Чтобы проверить, какими были числа, можно перед операцией сравнения тоже вывести их на экран.

Затем посчитаем средний балл: сложим две оценки и разделим на два. Подумать, какой тип данных может получиться в итоге? Результат также вывести на экран.

Запустите приложение несколько раз, посмотрите, как изменяются данные в консоли.

Третье задание
Малфой остался после уроков и получил задание: получить остатки от деления на 13, 14, 15, 16, 17, 19 числа 4199. Затем вычислить сумму остатков от деления.

Давайте напишем код, который поможет ему это посчитать. Продолжаем работать в методe main.
    *
    *
    * __________________________________________
    *
    * Строки
📄 60 мин




Вы заходите в огромный кабинет профессора заклинаний и располагаетесь за длинным столом в форме буквы П. Достаете пергамент, перо и готовитесь вести длинный конспект. Вокруг шум и возня других студентов — кто-то уронил банку с чернилами.

— Тергео! — слышите вы, но совсем не видите, откуда было направлено заклинание. Воцаряется тишина, чернильные пятна моментально исчезают, а на противоположенную сторону стола по небольшим ступенькам поднимается профессор заклинаний. Вы много слышали о Флитвике, но сегодня впервые видите его. Маленький мужчина с пышной седой бородой и тонким голосом пользуется огромным уважением среди преподавателей.

Вот так, стоя прямо на вашем столе, профессор начинает занятие.


String — один из самых популярных типов данных, заслуживающий отдельного урока. Он нужен для хранения и управления строками с заклинаниями. Заклинания веками хранятся в форме записей в разных источниках. Мы создаем новые заклинания так:

String charm = "Wingardium Leviosa";
Это не единственный способ. Объект строки (любую конкретную строку) можно создать с помощью оператора new, как и многие другие объекты:

// new - это оператор создания разных объектов
String charm = new String("Tergeo");
Оба варианта сработают хорошо и именно так, как вы ожидаете. Строки поддерживают только операцию сложения. Когда мы соединяем между собой две строки, то есть складываем их, на самом деле появляется третья, новая, строка. Она записывается в отдельную ячейку памяти и хранит внутри себя новое значение — первая строка + вторая строка.

String wingardium = "Wingardium ";
String leviosa= "Leviosa";

// Будет равно "Wingardium Leviosa"
String combination = wingardium + leviosa;
Также, в строках можно использовать специальные символы. Например, есть символ переноса строки — /n или символ табуляции — /t:

// \\n - перенос строки
String equations = "2 + 2 = 4" + "\\n" + "3 + 3 = 9" + "\\n";

// \\t - табуляция
String tabs = "Заголовок!" +
        "\\n" + "\\t" + "Абзац 1" +
        "\\n" + "\\t" + "Абзац 2";

System.out.println(equations + tabs);
Получим результат:

2 + 2 = 4
3 * 3 = 9
Заголовок!
    Абзац 1
    Абзац 2
Ещё можно использовать строку с переносами строк через три кавычки. Это инновация, о которой знают не все волшебники:

String lines = """
			Protego Maxima!
			Repello Inimicum!
			Fianto Duri!
""";
Класс String содержит разные методы. Вы можете нажать на String колесиком мышки — так вы попадете в сам этот класс и сможете посмотреть его описание и методы, которые в нем имеются. Рассмотрим наиболее полезные из них.

Метод сравнения строк: equals

Этот метод можно вызвать на любой строке, а в скобки ему передать какую-то другую строку. В результате получим true, если сравниваемые строки одинаковые, и false — если разные. Строки нужно сравнивать именно с помощью equals.

Почему мы не можем сравнить строки также, как числа, с помощью оператора ==? Вообще говоря, можем, только при таком виде сравнения никто не сможет гарантировать, что результат будет верным.

Все дело в том, что у строки есть значение, а есть адрес в ячейке памяти. Эти два параметра совсем разные. Значение — это то самое заклинание, которые мы сами можем написать и положить в какую-то строку. А вот адрес памяти каждой строке выдает компьютер — мы его просто так увидеть не можем. И вот, если мы попытаемся сравнить две строки оператором ==, то будут сравниваться именно адреса в памяти, а не внутреннее наполнение этих строк. Таким образом, мы можем получить в ответ false, даже если две строки совсем одинаковые.


Сравнение через == вернет нам true, если сравниваемые строки лежат по одному адресу.

String s1 = "Wingardium Leviosa";
String s2 = "Wingardium" + " " + "Leviosa";
String s3 = "Wingardium Leviosa Wingardium Leviosa";

// Получим true
System.out.println(s1.equals(s2));
// Получим false
System.out.println(s1.equals(s3));
Методы смены регистра: toLowerCase, toUpperCase.

Мы можем на любой строке вызвать любой из этих методов, и она или уменьшится, или увеличится!

String s1 = "REDUCIO";
String s2 = "inflatus";

// Получится "reducio"
System.out.println(s1.toLowerCase());
// Получится "INFLATUS";
System.out.println(s2.toUpperCase());
Метод получения конкретного символа: charAt.

String charm = "CHARM";

// Получим 'C'
System.out.println(charm.charAt(0));

// Получим 'M'
System.out.println(charm.charAt(4));

// Получим ошибку, так как в строке нет символа под номером 8
System.out.println(charm.charAt(8));
// Получим ошибку, так как не поддерживаются отрицательные индексы
System.out.println(charm.charAt(-1));
Метод получения длины строки: length.

String str = "Bombarda Maxima!"
// Получим 16. Пробелы и символы - считаются!
System.out.println(str.length());
Метод сравнения начала и конца строки: startsWith, endsWith.

String charm = "Bombarda Maxima!";

// Получим true
boolean charmStart1 = charm.startsWith("Bom");
// Получим false
boolean charmStart2 = charm.startsWith("ard");

// Получим true
boolean charmEnd1 = charm.endsWith("xima!");
// Получим false
boolean charmEnd2 = charm.endsWith("Max");
Метод получения подстроки: indexOf, contains.

String charm = "Bombarda Maxima!";

// Получим 9, начиная с 9-го символа в строке содержится "Maxima"
System.out.println(charm.indexOf("Maxima"));
// Получим -1, потому что такой подстроки нет
System.out.println(charm.indexOf("schooooooool"));

// contains вернёт true, если подстрока содержится в строке
System.out.println(charm.contains("Bom"));
// contains вернёт false, если подстрока НЕ содержится в строке
System.out.println(charm.contains("Bum"));
Методы замены подстроки: replace, replaceAll.

String charm = "Bombarda Maxima!";
String result1 = charm.replace("Bombarda", "Wow!"); // заменяет "Bombarda" на "Wow!"
System.out.println(result1); // получим "Wow! Maxima!"

String result2 = charm.replaceAll("a", "0"); // заменяет все a в строке charm на 0
System.out.println(result2); // получим "Bomb0rd0 M0xim0!"
Метод затирания пробельных символов в начале и в конце строки: trim.

String charm = "\\n   \\t Accio  \\t \\n    ";
String result = charm.trim();
// получим просто "Accio" - все отступы пропадут, а длина строки изменится
System.out.println(result);
Методы проверки строки на пустоту: isEmpty, isBlank.

В чем разница? isEmpty проверит, что строка вообще пустая. То есть выглядит вот так: “”. Внутри кавычек вообще ничего нет. И если строка действительно такая, то вернет true.

isBlank вернет true, если строка пустая — “” или если содержит только пробельные символы: “ “.

String s1 = " _ ";
String s2 = "\t      \n";
String s3 = "";

// Получим false и false
System.out.println(s1.isBlank());
System.out.println(s1.isEmpty());

// Получим true и false
System.out.println(s2.isBlank());
System.out.println(s2.isEmpty());

// Получим true и true
System.out.println(s3.isBlank());
System.out.println(s3.isEmpty());
Метод получения подстроки: substring.

String str = "123456";

// Левая граница включительно, правая не включительно
String result1 = str.substring(1, 5);
// Получим строку "2345"
System.out.println(result1);

// Начиная со второго индекса
String result2 = str.substring(2);
// Получим строку "3456"
System.out.println(result2);
💡 Индексация всегда начинается с нуля!

Обратите внимание, что ко всем этим методам мы обращаемся именно через имя строки. То есть обращаемся к конкретному объекту, и у него вызываем нужный метод. Но это еще не все! Мы можем обратиться к самому классу String и посмотреть его методы тоже.

String.valueOf() превращает число или символ в строку:

// Получим строку из 2-х рандомных чисел
// Результат сложения строки с числом – строка, не число
String initial = String.valueOf(50) + 11;
Что здесь происходит? Сначала 50 из числа превращается в строку, а затем к этой строке мы прибавляем 11. Если попытаться к любой строке прибавить число, то получится строка. Поэтому результат этого выражения будет 5011, а не 61. Хе-хе.

String.join() соединяет несколько строк через разделитель:

// Соединяем строки через пробел
// Первый аргумент метода – разделитель (передаем пробел)
String result1 = String.join(" ", "Bombarda", "Maxima", "!");
// Получим строку "Bombarda Maxima !"
System.out.println(result1);

String result2 = String.join(", ", "1", "2", "3", "4", "5");
// Получим строку "1, 2, 3, 4, 5"
System.out.println(result2);
String.format() форматирует строку:

String res1 = String.format("Строка - %s, Число - %d", "Accio", 42);
// Получим "Строка - Accio, Число - 42"
System.out.println(res1);
%s — представление строки, %d — представление числа.

StringBuilder
Как мы уже сказали выше, когда мы складываем строки, то для суммарной строки всегда создается новая строка, то есть выделяется дополнительная память. Чтобы не засорять память компьютера огромным количеством разных строк, придумали StringBuilder. Это класс с удобными методами, который позволяет эффективно манипулировать строками.

// Создаём StringBuilder
StringBuilder builder = new StringBuilder();

// Друг за другом можно добавлять строки или числа в конец строки
builder.append("Wingardium ")
        .append("Leviosa");

// builder.toString() вернёт получившуюся строку
String result = builder.toString();
// Wingardium Leviosa
System.out.println(result);
В чём же секрет? Разве StringBuilder не оперирует теми же строками, которые создаются каждый раз? Оказывается, StringBuilder создаёт внутри себя большой массив, внутри которого можно просто менять значения конкретного индекса. Идея в том, что этот массив выделяется один раз большой, и если в коде нужно создать большую строку в цикле, тогда можно воспользоваться StringBuilder что бы оптимизировать процесс.

Выглядит примерно так:


Так же как у String, у StringBuilder есть разные методы для управления строкой, перечислим наиболее популярные:

indexOf — возвращает индекс подстроки, или -1 если не содержится;

substring — возвращает подстроку;

equals — сравнивает строки внутри StringBuilder;

replace — заменяет подстроку.

StringBuilder sb = new StringBuilder("Wingardium Leviosa");
// Границы строки и то, на что нужно заменить подстроку
sb.replace(0, 9, "123456789");

// Получим "123456789 Leviosa"
System.out.println(sb);
reverse переворачивает строку:

StringBuilder builder = new StringBuilder();
builder.append("123")
        .append(456);

// Метод перевернёт строку внутри StringBuilder
builder.reverse();
String result = builder.toString();

// Получим строку "654321"
System.out.println(result);
deleteCharAt — удаляет конкретный символ под индексом;

delete — удаляет подстроку:

StringBuilder charm = new StringBuilder("Accio");
// Указываем границы подстроки для удаления
charm.delete(1, 3);
// Получим "Aio" - начало включительно, конец - нет!
System.out.println(charm);

charm.deleteCharAt(0);
charm.deleteCharAt(1);
// Получим "i". Обратите внимание, результат предыдущих операций сохраняется
System.out.println(charm);
Обратите внимание, методы модификации строки у StringBuilder не возвращают результат, например reverse, delete, deleteCharAt, replace. В отличие от String, где результат тут же возвращается, потому что нельзя поменять строку, создаётся каждый раз новая.
*
* Первое задание
Создайте строку из 5 случайных чисел new Random().nextInt().

Замените все единицы на символ ‘i’.

У получившейся строки уберите все символы ‘-’

У получившейся строки замените все нули на символ ‘o’.

У получившейся строки замените все шестерки на символ ‘b’.

Выведите результат в консоль.

Узнайте, содержится ли подстрока “23” у получившейся строки.

Узнайте индекс подстроки “ob”.

Второе задание (усложненное)
Для начала скопируйте в класс Main проекта Magic следующий код:

public static void castSpell() {

}
Его нужно вставить под метод main, в котором до этого мы вели всю работу. Этот код представляет собой новый метод, который мы затем сможем вызвать внутри метода main. Затем надо вызвать новый метод из метода main. Для этого просто пишем его название внутри main. После выполнения этого действия у вас должно получиться что-то такое:

public class Main {
    public static void main(String[] args) {
        // какой-то код
				castSpell();
    }

    public static void castSpell() {

    }
}
Теперь работаем внутри метода castSpell().

1. Создайте строку в верхнем регистре: ARDENTIS VERUM LUMINOS ET FULGUR SYLVESTRA ELIXIA.

2. Приведите строку к нижнему регистру.

3. Создайте случайное число int start с помощью класса Random. Число должно быть в диапазоне от 0 до 50.

4. Создайте подстроку от строки, содержащей слова заклинаний, которая будет начинаться с индекса, равного start.

5. Создайте объект класса StringBuilder spell, запишите полученную строку выше в этот объект.

6. Разверните строку задом наперед.

7. В полученной строке поменяйте местами символы под 0 и 1 индексами. * (обратитесь к методу replace: сначала получите символы(одна буква или символ пробела) под этими индексами с помощью метода charAt, а затем используйте их для замены). Должно получиться что-то такое:

builder.replace(0, 1, String.valueOf(one));
builder.replace(1,2, String.valueOf(zero));
8. Полученную строку выведите на экран. Запускаем метод main.

Прочитайте заклинание! Попробуйте запустить несколько раз и посмотрите, как меняется ваше заклинание. Подумайте, почему?
*
* _____________________________________
*
* Ветвление
📄 30 мин




Собирайтесь! Не толпитесь!

Вы пробираетесь среди толпы студентов поближе к домику лесничего. Уроки Хагрида всегда проходят шумно и, мягко говоря, непредсказуемо, потому что каждый раз он приносит из леса существо загадочнее и опаснее предыдущего. Вы в предвкушении выходите в первый ряд, чтобы сразу приступить к кормежке саблезубого кузнечика или успеть схватить лучшее снаряжение для погони за огненными летунами, как вдруг замечаете гору веток, сваленную у входа в домик. — Сегодня изучаем ветвление. — говорит Хагрид.

Вы только успеваете бросить на него вопросительный взгляд, как огромная ветка оказывается в ваших руках.


В Java, как и в любом другом языке высокого уровня, есть условные операторы. Они составляют основную логику любого алгоритма. Условные операторы нужны для того, чтобы в зависимости от какого-то условия выбрать нужное действие.

Условный оператор состоит из 2-х частей:

Первая – условие. Внутри этой части может содержаться любое выражение, в результате дающее значение типа boolean.

Вторая – код, который должен выполниться при выполнении условия. Этот код обрамляется фигурными скобками.


Рассмотрим, как это выглядит в коде:

int branchCount = new Random().nextInt(0, 10); //у ветки есть вот столько маленьких веточек

if (branchCount >= 8) { // нам нужно выбрать только ветки, у которых больше 8 или ровно 8 веточек
    System.out.println("Число больше или равно 8. Ветка подходит");
}
Здесь мы создали число в диапазоне от 0 до 10. Мы не знаем, каким точно оно будет сейчас. Задаем условие — число должно быть больше или равно 8, чтобы это условие выполнилось. Если число действительно такое, то на экран выведется строка. А если нет — ничего не произойдет.

А что, если нам нужно выполнить какое-то другое действие, если условие не выполнено? Тогда можно добавить блок else — иначе:

int branchCount = new Random().nextInt(0, 10);
if (branchCount >= 8) {
    System.out.println("Число больше или равно 8. Ветка подходит");
} else {
		System.out.println("Слишком маленько число. Мало веточек :с ");
}
Таким образом можно соединять несколько условных операторов. Давайте посмотрим:

int branchCount = new Random().nextInt(0, 10);
if (branchCount >= 8) {
    System.out.println("Кладем ветку в кучу больших веток");
} else if (branchCount == 5) {
    System.out.println("Древороги (существо с деревянным рогом) едят только ветки с пятью веточками!");
} else if (branchCount == 1) {
    System.out.println("Ну, это посох");
} else {
		System.out.println("Такие нам сейчас не нужны. Будем топить ими камин");
}
Сначала идёт единственный if, далее идёт сколько угодно else if, последним идёт единственный else. Обратите внимание, у последнего else нет первой части - условия, потому что эта ветка кода выполнится при НЕ выполнении всех условий выше. До последнего условия дойдут только те, которые не прошли по предыдущим.

💡 Порядок условных выражений важен! Так, например, начать условие с else if не получится!

Код условий читается сверху вниз, и выполнится только тот блок кода, у которого результат условия равен true.

А вот, например, код, условие в котором никогда не будет выполнено:

int number = 4;

if (number > 5) {
    number = number + 5;
    System.out.println("Теперь число больше 10");
}
System.out.println(number);
Если начальное число меньше, то блок if выполнен не будет. Выполнение кода продолжится сразу на строке System.out.println(number);. А все условие будет попросту проигнорировано.

Многие из нас еще в школе встречались с блок-схемами. Блок-схема — это самое наглядное представление работы условного оператора. Давайте посмотрим:


Обратили внимание, что на этой блок-схеме представлен выбор внутри другого выбора? Это — вложенное условие. Если одного условие выполнено, внутри него можно добавить еще одно условие. Такую цепочку можно продолжать сколько угодно. Давайте посмотрим на примере:

int branchCount = new Random().nextInt(0, 10);

if (branchCount >= 8) {
		if (branchCount == 10) {
				System.out.println("Огромная ветка!");
		} else {
		    System.out.println("Число больше или равно 8. Ветка подходит");
		}
}
Когда выполняется условие branchCount >= 8, мы хотим проверить, равно ли это число 10, и если да, хотим сделать еще какое-то действие. То есть, чтобы попасть внутри условия branchCount == 10, нужно, чтобы и первое и второе условие выполнились — вернули true.

Пойдем тренироваться!
*
* Первое задание
В методе main c помощью new Random().nextInt() сгенерируйте 2 случайных целых числа.

Если оба числа чётные, разделите каждое число на 2 и выведите в консоль сумму.

Иначе если только первое число делится на 2, разделите только первое число на 2 и выведите в консоль сумму полученного числа и второго числа.

Иначе, если только второе число делится на 2, разделите только второе число на 2 и выведите результат вычисления в консоль.

Иначе (если никакое число не делится на 2) просто выведите в консоль сумму этих чисел.

Второе задание (Усложненное, с подсказками)
Сначала нужно немного подготовиться и создать в нашем проекте Magic новый класс. В общем-то это просто новый файл в папке.

Открываем проект к идее как обычно и щелкаем правой кнопкой мыши по папке hogwarts. Появляется окошко, в котором нам надо выбрать New → Java Class


Нажимаем на Java Class, затем в появившемся окошке вводим название класса — SortingHat. Сейчас мы будем писать метод, который будет распределять студентов по факультетам!

В новом классе создаем новый метод. Для этого можете скопировать этот код:

public void sort() {

}
Итак. На распределении каждому студенту предлагается ответить на несколько вопросов, а затем, в зависимости от его ответа распределительная шляпа скажет, на каком факультете ему следует оказаться.

1. Создайте строки с вопросами. Один вопрос — одна строка.

“Ты предпочитаешь работать в команде? (Да/Нет)”

“Ты любишь разгадывать головоломки? (Да/Нет)”

“Ты идешь на риск, чтобы достичь своей цели? (Да/Нет)”

“Ты проявляешь заботу к существам и природе? (Да/Нет)”

2. Теперь, когда строки созданы, нужно сделать так, чтобы они последовательно выводились на экран, а затем пользователь должен ответить на вопрос. Действуем так: выводим первую строку на экран, затем из консоли считываем ответ пользователя. Чтобы считать ответ, используем класс Scanner и его метод nextLine(). Будет выглядеть примерно вот так:

System.out.println(question1);
String answer1 = scanner.nextLine();
3. Теперь, когда ответы на вопросы собраны, можем начинать распределение. В зависимости от ответа пользователя шляпа принимает решение по факультету. Ветвление!

Если ответ answer1 равен "Да", программа переходит к дальнейшим проверкам (начинается вложенное ветвление):

Если answer3 равен “Да”, то выбирается факультет Гриффиндор (System.*out*.println("Гриффиндор");).

Иначе, если answer4, выбирается факультет Пуффендуй.

Иначе, если answer2 равен "Да", программа переходит к дальнейшим проверкам (начинается вложенное ветвление):

Если answer1 равен "Да", то выбирается факультет Когтевран.

Иначе, если answer3 равен "Да", то выбирается факультет Когтевран.

Иначе выбирается факультет Слизерин.

Иначе, если answer3 равен "Да", то выбирается факультет Слизерин.

Иначе выбирается факультет Пуффендуй.

4. Отлично! Написали целый алгоритм по распределению! Давайте теперь его запустим. Чтобы это сделать, переходит в метод main в классе Main и пишем внутри метода main следующий код:

SortingHat sortingHat = new SortingHat();
sortingHat.sort();
Мы поговорим об этом коде в следующих уроках. А пока что наслаждаемся результатом работы! Запускаем метод main и проходим тест!
*
* _____________________________________


* */

}
